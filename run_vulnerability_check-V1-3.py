'''
Version 1.3 - it groups per device
'''

import os
import json
import re
import requests
from dotenv import load_dotenv
from packaging import version

# --- Configuration ---
API_BASE_URL = "https://apix.cisco.com/security/advisories/v2/product"
PRODUCT_NAME = "Meraki"
ADVISORIES_FOLDER = "csaf_advisories"
INVENTORY_FILE = "device_inventory.json"

def fetch_and_download_advisories(headers):
    """
    Fetches the list of advisories and downloads each CSAF file.
    This version is resilient to individual download failures.
    """
    print(f"--- Step 1: Fetching Advisory List for '{PRODUCT_NAME}' ---")
    params = {"product": PRODUCT_NAME}
    try:
        response = requests.get(API_BASE_URL, headers=headers, params=params)
        response.raise_for_status()
        data = response.json()
        advisories_list = data.get("advisories", [])
        if not advisories_list:
            print("No advisories found for the specified product.")
            return False
        if not os.path.exists(ADVISORIES_FOLDER):
            os.makedirs(ADVISORIES_FOLDER)
        print(f"Found {len(advisories_list)} advisories. Downloading to '{ADVISORIES_FOLDER}/'...\n")
        for advisory in advisories_list:
            csaf_url = advisory.get("csafUrl")
            advisory_id = advisory.get("advisoryId")
            if not (csaf_url and advisory_id): continue
            filename = os.path.join(ADVISORIES_FOLDER, f"{advisory_id}.json")
            try:
                resp_csaf = requests.get(csaf_url, headers=headers)
                resp_csaf.raise_for_status()
                try:
                    csaf_content = resp_csaf.json()
                    with open(filename, 'w') as f:
                        json.dump(csaf_content, f, indent=4)
                    print(f"  -> Successfully downloaded and saved {advisory_id}.json")
                except json.JSONDecodeError:
                    print(f"  [!] Warning: Could not parse JSON for advisory '{advisory_id}'. Skipping.")
            except requests.exceptions.HTTPError as http_err:
                print(f"  [!] Warning: HTTP error downloading file for '{advisory_id}'. Status: {http_err.response.status_code}. Skipping.")
        print("\n--- Advisory download complete. ---")
        return True
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 401: print("HTTP 401 Unauthorized: Your OAuth token is likely invalid or has expired.")
        elif e.response.status_code == 403: print("HTTP 403 Forbidden: Your token is valid, but lacks the necessary scopes/permissions.")
        else: print(f"An HTTP error occurred while fetching the main advisory list: {e}")
        return False
    except Exception as e:
        print(f"An unexpected error occurred during the initial fetch: {e}")
        return False

def print_advisory_summaries():
    """
    NEW FUNCTION: Prints a summary of each downloaded advisory.
    """
    print("\n--- Step 1.5: Downloaded Advisory Summaries ---")
    advisory_files = sorted([f for f in os.listdir(ADVISORIES_FOLDER) if f.endswith('.json')])
    if not advisory_files:
        print("No advisory files were found in the download folder.")
        return

    for filename in advisory_files:
        filepath = os.path.join(ADVISORIES_FOLDER, filename)
        with open(filepath, 'r') as f:
            try:
                advisory_data = json.load(f)
                document = advisory_data.get("document", {})
                notes = document.get("notes", [])
                summary_text = "Summary not found."
                for note in notes:
                    if note.get("category") == "summary":
                        # Clean up the text for a concise summary
                        summary_text = note.get("text", "Summary text is empty.").strip().replace('\r\n', ' ')
                        break
                
                print(f"\nAdvisory: {filename}")
                print(f"  Summary: {summary_text}")
            except json.JSONDecodeError:
                print(f"\nAdvisory: {filename}")
                print("  Summary: Could not parse this JSON file.")
    print("\n-------------------------------------------------")


def parse_fixed_software_rules(notes):
    """
    Parses the 'Fixed Software' note by splitting the text into tokens and iterating
    through them. This is much more robust than a single regex.
    """
    rules = {}
    for note in notes:
        if note.get("title") == "Fixed Software":
            text_content = note.get("text", "")
            tokens = text_content.split()
            for i, token in enumerate(tokens):
                is_train_version = re.fullmatch(r"^\d+(\.\d+)?$", token)
                if is_train_version and (i + 1) < len(tokens):
                    next_token = tokens[i+1]
                    is_fix_version = re.fullmatch(r"^\d+(\.\d+){2,}$", next_token)
                    if next_token == "Migrate":
                        rules[token] = "migrate"
                    elif is_fix_version:
                        rules[token] = next_token
    return rules

def analyze_inventory_against_advisories():
    """
    Loops through advisories, correlates them against the inventory, and
    generates a final report grouped by each affected device.
    """
    print(f"--- Step 2: Analyzing Inventory against downloaded Advisories ---")
    try:
        with open(INVENTORY_FILE, 'r') as f:
            inventory_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: Inventory file not found at '{INVENTORY_FILE}'. Aborting analysis.")
        return

    advisory_files = [f for f in os.listdir(ADVISORIES_FOLDER) if f.endswith('.json')]
    
    # NEW: A dictionary to hold all findings, keyed by device serial number.
    # Format: { "SERIAL": { "name": "...", "model": "...", "vulnerabilities": [...] } }
    affected_devices_report = {}

    # This first loop gathers all the data efficiently by reading each advisory file only once.
    for filename in advisory_files:
        filepath = os.path.join(ADVISORIES_FOLDER, filename)
        with open(filepath, 'r') as f:
            advisory_data = json.load(f)

        document = advisory_data.get("document", {})
        notes = document.get("notes", [])
        
        fixed_rules = parse_fixed_software_rules(notes)
        if not fixed_rules: continue

        vulnerable_products = []
        for note in notes:
            if note.get("title") == "Vulnerable Products":
                lines = note.get("text", "").splitlines()
                vulnerable_products.extend([line.strip() for line in lines if re.fullmatch(r'([a-zA-Z0-9-]+)', line.strip())])

        if not vulnerable_products: continue

        # Correlate this advisory against every device in the inventory
        for device in inventory_data:
            device_model = device.get("model", "")
            if any(device_model.startswith(vp) for vp in vulnerable_products):
                firmware_str = next((d['value'] for d in device.get('details', []) if d.get('name') == 'Running software version'), None)
                if not firmware_str or not firmware_str.startswith("MX"): continue

                try:
                    device_version_str = firmware_str.split(" ")[1]
                    device_version = version.parse(device_version_str)
                    
                    best_matching_train = None
                    sorted_trains = sorted(fixed_rules.keys(), key=len, reverse=True)
                    for train in sorted_trains:
                        if device_version_str.startswith(train):
                            best_matching_train = train
                            break
                    
                    if not best_matching_train: continue

                    fix_rule = fixed_rules[best_matching_train]
                    is_vulnerable = False
                    
                    if fix_rule == "migrate": is_vulnerable = True
                    elif fix_rule:
                        if device_version < version.parse(fix_rule): is_vulnerable = True
                    
                    if is_vulnerable:
                        # --- THIS IS THE CORE LOGIC CHANGE ---
                        serial = device.get("serial")
                        
                        # If this is the first time we see this device, create its entry.
                        if serial not in affected_devices_report:
                            affected_devices_report[serial] = {
                                "name": device.get("name", "N/A"),
                                "serial": serial,
                                "model": device_model,
                                "firmware": firmware_str,
                                "vulnerabilities": [] # Initialize an empty list for its vulnerabilities
                            }
                        
                        # Append the current vulnerability to this device's list.
                        affected_devices_report[serial]["vulnerabilities"].append({
                            "advisory_id": document.get('tracking', {}).get('id', filename),
                            "title": document.get('title', 'N/A'),
                            "fix_recommendation": fix_rule
                        })
                except (IndexError, AttributeError):
                    continue

    # --- NEW: This entire reporting block runs AFTER all files have been processed ---
    if not affected_devices_report:
        print("\nAnalysis complete. No vulnerable devices found in your inventory for the downloaded advisories.")
    else:
        print(f"\n--- Analysis Complete: Found vulnerabilities on {len(affected_devices_report)} device(s) ---")
        
        # Loop through the final report dictionary and print the device-centric view
        for serial, device_data in affected_devices_report.items():
            print(f"\n==============================================================================")
            print(f"DEVICE: {device_data['name']} (Model: {device_data['model']}, Serial: {device_data['serial']})")
            print(f"  Current Firmware: {device_data['firmware']} (Vulnerable)")
            print("------------------------------------------------------------------------------")
            print("  Affected by:")
            
            for vuln in device_data['vulnerabilities']:
                recommendation = vuln['fix_recommendation']
                if recommendation == 'migrate':
                    rec_text = "Migrate to a fixed release."
                else:
                    rec_text = f"Upgrade to {recommendation} or later."

                print(f"    - Advisory: {vuln['advisory_id']}")
                print(f"      Title: {vuln['title']}")
                print(f"      Recommendation: {rec_text}")
        print(f"\n==============================================================================")

def main():
    load_dotenv()
    oauth_token = os.getenv("CISCO_API_TOKEN")
    if not oauth_token:
        print("Error: 'CISCO_API_TOKEN' not found. Please check your .env file or environment variables.")
        return
    headers = {"Authorization": f"Bearer {oauth_token}", "Accept": "application/json"}
    
    if fetch_and_download_advisories(headers):
        print_advisory_summaries() # ADDED: Call the new summary function
        analyze_inventory_against_advisories()

if __name__ == "__main__":
    main()
